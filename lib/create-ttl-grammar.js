'use strict';

/*global atom*/
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTLSCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this, 10000)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, err => {
        if (err) {
          reject(new Error(`Unable to add Grammar to registry\n${ filename }`));
        } else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a ttl filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename;
    let ttlFilenameAbsolute = _ref.ttlFilenameAbsolute;
    let grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {
      this.doesGrammarFileExist(ttlFilename).then(ifFileExists => {
        if (ifFileExists) {
          resolve();
        } else {
          this.removeGrammars();
          this.removeTtlLanguageFiles().then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => {
            atom.notifications.addInfo('language-babel', { detail: `Grammar created at \n${ ttlFilenameAbsolute }`, dismissable: true });
            resolve(ttlFilename);
          }).catch(err => {
            atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
            reject(err);
          });
        }
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject(new Error(err));else resolve();
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${ this.TTLSCOPENAME }",
  "fileTypes": [],
  "patterns": [
    ${ this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString)) }
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/;

    if (matchString.length < 1 || !isValidIncludeScope.test(includeScope)) {
      throw new Error(`Error in the Tagged Template Grammar String ${ ttlString }`);
    }

    const isRegExp = /^\".*\"$/;
    if (isRegExp.test(matchString)) {
      // Found a possible regexp in the form /regex/ so strip the /
      // This is a oniguruma regex but we will do a simple JS regex test for
      // validity as it is most likely close enough!
      matchString = matchString.substring(1, matchString.length - 1);
      try {
        new RegExp(matchString).test("");
      } catch (err) {
        throw new Error(`You entered an badly formed RegExp in the Tagged Template Grammar settings.\n/${ matchString }/`);
      }
    } else {
      const escapeStringRegExp = /[|\\{}()[\]^$+*?.]/g;
      // Get a valid regexp escaped string. e.g. '/** @html */' -> '\/\*\* @html \*\/'
      matchString = matchString.replace(escapeStringRegExp, '\\\\$&');
    }

    return `{
      "begin": "\\\\s*+(${ matchString })\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.js" },
        "4": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "source.js.jsx#literal-quasi-embedded" },
        { "include": "${ includeScope }" }
      ]
    }`;
  }

  // checks a ttl grammar filename exists
  // returns a Promise that resolves to true if ttlFileName exists
  doesGrammarFileExist(ttlFilename) {
    return new Promise(resolve => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, err => {
        err ? resolve(false) : resolve(true);
      });
    });
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject(new Error(err));else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return (/^ttl-/.test(filename)
      );
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    let hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${ hashString }.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(timeout) {
    if (this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText });
      } catch (err) {
        atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
      }
    }, timeout);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTLSCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZS10dGwtZ3JhbW1hci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxNQUFNLFNBQVMsUUFBUSxRQUFSLENBQWY7QUFDQSxNQUFNLEtBQUssUUFBUSxJQUFSLENBQVg7QUFDQSxNQUFNLE9BQU8sUUFBUSxNQUFSLENBQWI7QUFDQSxNQUFNLHNCQUFzQixRQUFRLE1BQVIsRUFBZ0IsbUJBQTVDOzs7O0FBSUEsT0FBTyxPQUFQLEdBQ0EsTUFBTSxnQkFBTixDQUF1Qjs7QUFNckIsZ0JBQW1DO0FBQUEsUUFBdkIsYUFBdUIseURBQVAsS0FBTztBQUFBLFNBSm5DLFVBSW1DLEdBSnRCLElBQUksbUJBQUosRUFJc0I7QUFBQSxTQUhuQyxrQkFHbUMsR0FIZixJQUdlO0FBQUEsU0FGbkMsWUFFbUMsR0FGcEIsQ0FBQywwQkFBRCxDQUVvQjs7QUFDakMsUUFBSSxhQUFKLEVBQXFCOztBQUVuQixXQUFLLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBb0IsS0FBSyxNQUFMLENBQVksT0FBWixDQUFvQixzQ0FBcEIsRUFBNEQsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixDQUEyQixJQUEzQixFQUFpQyxLQUFqQyxDQUE1RCxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsWUFBVTtBQUNSLFNBQUssVUFBTCxDQUFnQixPQUFoQjtBQUNEOzs7QUFHRCxjQUFZLFFBQVosRUFBc0I7QUFDcEIsV0FBTyxJQUFJLE9BQUosQ0FBWSxDQUFDLE9BQUQsRUFBVSxNQUFWLEtBQXFCO0FBQ3RDLFdBQUssUUFBTCxDQUFjLFdBQWQsQ0FBMEIsUUFBMUIsRUFBcUMsR0FBRCxJQUFTO0FBQzNDLFlBQUksR0FBSixFQUFTO0FBQ1AsaUJBQU8sSUFBSSxLQUFKLENBQVUsQ0FBQyxtQ0FBRCxHQUFzQyxRQUF0QyxFQUErQyxBQUEvQyxDQUFWLENBQVA7QUFDRCxTQUZELE1BR0s7QUFDTixPQUxEO0FBTUQsS0FQTSxDQUFQO0FBU0Q7Ozs7OztBQU1ELHNCQUErRDtBQUFBLFFBQWhELFdBQWdELFFBQWhELFdBQWdEO0FBQUEsUUFBbkMsbUJBQW1DLFFBQW5DLG1CQUFtQztBQUFBLFFBQWQsV0FBYyxRQUFkLFdBQWM7O0FBQzdELFdBQU8sSUFBSSxPQUFKLENBQVksQ0FBQyxPQUFELEVBQVUsTUFBVixLQUFxQjtBQUN0QyxXQUFLLG9CQUFMLENBQTBCLFdBQTFCLEVBQ0csSUFESCxDQUNTLFlBQUQsSUFBa0I7QUFDdEIsWUFBSSxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0QsU0FGRCxNQUdLO0FBQ0gsZUFBSyxjQUFMO0FBQ0EsZUFBSyxzQkFBTCxHQUNDLElBREQsQ0FDTSxNQUFNLEtBQUssaUJBQUwsQ0FBdUIsbUJBQXZCLEVBQTRDLFdBQTVDLENBRFosRUFFQyxJQUZELENBRU0sTUFBTSxLQUFLLFdBQUwsQ0FBaUIsbUJBQWpCLENBRlosRUFHQyxJQUhELENBR00sTUFBTTtBQUNWLGlCQUFLLGFBQUwsQ0FBbUIsT0FBbkIsQ0FBMkIsZ0JBQTNCLEVBQTZDLEVBQUMsUUFBUSxDQUFDLHFCQUFELEdBQXdCLG1CQUF4QixFQUE0QyxBQUE1QyxDQUFULEVBQXVELGFBQWEsSUFBcEUsRUFBN0M7QUFDQSxvQkFBUSxXQUFSO0FBQ0QsV0FORCxFQU9DLEtBUEQsQ0FPUSxHQUFELElBQVM7QUFDZCxpQkFBSyxhQUFMLENBQW1CLFVBQW5CLENBQThCLGdCQUE5QixFQUFnRCxFQUFDLFFBQVEsQ0FBQyxBQUFELEdBQUcsSUFBSSxPQUFQLEVBQWUsQUFBZixDQUFULEVBQTBCLGFBQWEsSUFBdkMsRUFBaEQ7QUFDQSxtQkFBTyxHQUFQO0FBQ0QsV0FWRDtBQVdEO0FBQ0YsT0FuQkg7QUFvQkQsS0FyQk0sQ0FBUDtBQXNCRDs7O0FBR0Qsb0JBQWtCLFFBQWxCLEVBQTJCLElBQTNCLEVBQWlDO0FBQy9CLFdBQU8sSUFBSSxPQUFKLENBQVksQ0FBQyxPQUFELEVBQVUsTUFBVixLQUFxQjtBQUN0QyxTQUFHLFNBQUgsQ0FBYSxRQUFiLEVBQXVCLElBQXZCLEVBQThCLEdBQUQsSUFBUztBQUNwQyxZQUFJLEdBQUosRUFBUyxPQUFPLElBQUksS0FBSixDQUFVLEdBQVYsQ0FBUCxFQUFULEtBQ0s7QUFDTixPQUhEO0FBSUQsS0FMTSxDQUFQO0FBTUQ7OztBQUdELHNCQUFvQjtBQUNsQixXQUFPLENBQUM7OztnQkFBRCxHQUdPLEtBQUssWUFIWixFQUd5Qjs7O0lBSHpCLEdBTUwsS0FBSyxZQUFMLEdBQW9CLEdBQXBCLENBQXlCLFNBQUQsSUFBZ0IsS0FBSyxxQkFBTCxDQUEyQixTQUEzQixDQUF4QyxDQU5LOztDQUFBLENBQVA7QUFTRDs7OztBQUlELHdCQUFzQixTQUF0QixFQUFpQztBQUMvQixRQUFJLGlCQUFpQixVQUFVLFdBQVYsQ0FBc0IsR0FBdEIsQ0FBckI7QUFDQSxRQUFJLGNBQWMsVUFBVSxTQUFWLENBQW9CLENBQXBCLEVBQXVCLGNBQXZCLENBQWxCO0FBQ0EsUUFBSSxlQUFlLFVBQVUsU0FBVixDQUFvQixpQkFBZSxDQUFuQyxDQUFuQjtBQUNBLFVBQU0sc0JBQXNCLDhDQUE1Qjs7QUFFQSxRQUFJLFlBQVksTUFBWixHQUFxQixDQUFyQixJQUEwQixDQUFDLG9CQUFvQixJQUFwQixDQUF5QixZQUF6QixDQUEvQixFQUF1RTtBQUNyRSxZQUFNLElBQUksS0FBSixDQUFVLENBQUMsNENBQUQsR0FBK0MsU0FBL0MsRUFBeUQsQUFBekQsQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsVUFBTSxXQUFXLFVBQWpCO0FBQ0EsUUFBSyxTQUFTLElBQVQsQ0FBYyxXQUFkLENBQUwsRUFBa0M7Ozs7QUFJaEMsb0JBQWMsWUFBWSxTQUFaLENBQXNCLENBQXRCLEVBQXlCLFlBQVksTUFBWixHQUFvQixDQUE3QyxDQUFkO0FBQ0EsVUFBSTtBQUFFLFlBQUksTUFBSixDQUFXLFdBQVgsQ0FBRCxDQUEwQixJQUExQixDQUErQixFQUEvQjtBQUFvQyxPQUF6QyxDQUNBLE9BQU8sR0FBUCxFQUFZO0FBQ1YsY0FBTSxJQUFJLEtBQUosQ0FBVSxDQUFDLDhFQUFELEdBQWlGLFdBQWpGLEVBQTZGLENBQTdGLENBQVYsQ0FBTjtBQUNEO0FBQ0YsS0FURCxNQVVLO0FBQ0gsWUFBTSxxQkFBcUIscUJBQTNCOztBQUVBLG9CQUFjLFlBQVksT0FBWixDQUFvQixrQkFBcEIsRUFBd0MsUUFBeEMsQ0FBZDtBQUNEOztBQUVELFdBQU8sQ0FBQzt3QkFBRCxHQUNlLFdBRGYsRUFDMkI7Ozs7Ozs7Ozs7O3NCQUQzQixHQVlhLFlBWmIsRUFZMEI7O0tBWjFCLENBQVA7QUFlRDs7OztBQUlELHVCQUFxQixXQUFyQixFQUFrQztBQUNoQyxXQUFPLElBQUksT0FBSixDQUFhLE9BQUQsSUFBYTtBQUM5QixTQUFHLE1BQUgsQ0FBVSxLQUFLLCtCQUFMLENBQXFDLFdBQXJDLENBQVYsRUFBNkQsR0FBRyxJQUFoRSxFQUF1RSxHQUFELElBQVM7QUFDN0UsY0FBTSxRQUFRLEtBQVIsQ0FBTixHQUFzQixRQUFRLElBQVIsQ0FBdEI7QUFDRCxPQUZEO0FBR0QsS0FKTSxDQUFQO0FBS0Q7OztBQUdELG1CQUFpQjtBQUNmLFdBQU8sS0FBSyxTQUFMLENBQ0wsS0FBSyxPQUFMLENBQWEsS0FBSyxRQUFMLENBQWMsY0FBZCxDQUE2QixnQkFBN0IsRUFBK0MsSUFBNUQsRUFBa0UsWUFBbEUsQ0FESyxDQUFQO0FBR0Q7OztBQUdELG9CQUFrQjtBQUNoQixXQUFPLElBQUksT0FBSixDQUFZLENBQUMsT0FBRCxFQUFTLE1BQVQsS0FBb0I7QUFDckMsU0FBRyxPQUFILENBQVcsS0FBSyxjQUFMLEVBQVgsRUFBaUMsQ0FBQyxHQUFELEVBQU0sSUFBTixLQUFlO0FBQzlDLFlBQUksR0FBSixFQUFTLE9BQU8sSUFBSSxLQUFKLENBQVUsR0FBVixDQUFQLEVBQVQsS0FDSztBQUNILGtCQUFRLElBQVI7QUFDRDtBQUNGLE9BTEQ7QUFNRCxLQVBNLENBQVA7QUFRRDs7O0FBR0QsaUJBQWU7QUFDYixXQUFPLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsZ0JBQWhCLEVBQWtDLHFCQUF6QztBQUNEOzs7QUFHRCx1QkFBcUI7QUFDbkIsV0FBTyxLQUFLLGVBQUwsR0FBdUIsSUFBdkIsQ0FBNEIsWUFBWSxTQUFTLE1BQVQsQ0FBZ0IsVUFBUyxRQUFULEVBQW1CO0FBQ2hGLGFBQU8sU0FBUSxJQUFSLENBQWEsUUFBYjtBQUFQO0FBQ0QsS0FGOEMsQ0FBeEMsQ0FBUDtBQUdEOzs7QUFHRCxvQkFBa0IsWUFBbEIsRUFBZ0M7QUFDOUIsUUFBSSxPQUFPLE9BQU8sVUFBUCxDQUFrQixRQUFsQixDQUFYO0FBQ0EsU0FBSyxNQUFMLENBQVksWUFBWjtBQUNBLFdBQU8sS0FBSyxNQUFMLENBQVksS0FBWixDQUFQO0FBQ0Q7OztBQUdELHlCQUF1QixVQUF2QixFQUFtQztBQUNqQyxXQUFPLENBQUMsSUFBRCxHQUFPLFVBQVAsRUFBa0IsS0FBbEIsQ0FBUDtBQUNEOzs7QUFHRCxrQ0FBZ0MsV0FBaEMsRUFBNkM7QUFDM0MsV0FBTyxLQUFLLE9BQUwsQ0FBYSxLQUFLLGNBQUwsRUFBYixFQUFvQyxXQUFwQyxDQUFQO0FBQ0Q7Ozs7Ozs7QUFRRCxtQkFBaUIsT0FBakIsRUFBMEI7QUFDeEIsUUFBSSxLQUFLLGtCQUFULEVBQTZCLGFBQWEsS0FBSyxrQkFBbEI7QUFDN0IsU0FBSyxrQkFBTCxHQUEwQixXQUFXLE1BQU07QUFDekMsVUFBSTtBQUNGLGNBQU0sY0FBYyxLQUFLLGlCQUFMLEVBQXBCO0FBQ0EsY0FBTSxPQUFPLEtBQUssaUJBQUwsQ0FBdUIsV0FBdkIsQ0FBYjtBQUNBLGNBQU0sY0FBYyxLQUFLLHNCQUFMLENBQTRCLElBQTVCLENBQXBCO0FBQ0EsY0FBTSxzQkFBc0IsS0FBSywrQkFBTCxDQUFxQyxXQUFyQyxDQUE1QjtBQUNBLGFBQUssYUFBTCxDQUFtQixFQUFDLFdBQUQsRUFBYyxtQkFBZCxFQUFtQyxXQUFuQyxFQUFuQjtBQUNELE9BTkQsQ0FPQSxPQUFNLEdBQU4sRUFBVztBQUNULGFBQUssYUFBTCxDQUFtQixVQUFuQixDQUE4QixnQkFBOUIsRUFBZ0QsRUFBQyxRQUFRLENBQUMsQUFBRCxHQUFHLElBQUksT0FBUCxFQUFlLEFBQWYsQ0FBVCxFQUEwQixhQUFhLElBQXZDLEVBQWhEO0FBQ0Q7QUFDRixLQVh5QixFQVd2QixPQVh1QixDQUExQjtBQVlEOzs7QUFHRCxtQkFBaUI7QUFDZixTQUFLLFFBQUwsQ0FBYyx5QkFBZCxDQUF3QyxLQUFLLFlBQTdDO0FBQ0Q7OztBQUdELDJCQUF5QjtBQUN2QixXQUFPLEtBQUssa0JBQUwsR0FBMEIsSUFBMUIsQ0FBZ0MsZUFBRCxJQUFxQjtBQUN6RCxXQUFLLElBQUksa0JBQVQsSUFBK0IsZUFBL0IsRUFBZ0Q7QUFDOUMsWUFBSSx5QkFBeUIsS0FBSywrQkFBTCxDQUFxQyxrQkFBckMsQ0FBN0I7QUFDQSxXQUFHLE1BQUgsQ0FBVSxzQkFBVjtBQUNEO0FBQ0YsS0FMTSxDQUFQO0FBT0Q7QUE5Tm9CLENBRHZCIiwiZmlsZSI6ImNyZWF0ZS10dGwtZ3JhbW1hci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIGF0b20qL1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBDb21wb3NpdGVEaXNwb3NhYmxlID0gcmVxdWlyZSgnYXRvbScpLkNvbXBvc2l0ZURpc3Bvc2FibGU7XHJcblxyXG4vLyBUaGlzIENsYXNzIGlzIHJlcHNvbnNpYmxlIGZvciBjcmVhdGluZyBhIG5ldyBUYWdnZWQgVGVtcGxhdGUgZ3JhbW1hclxyXG4vLyBvbiBkZXRlY3Rpb24gb2YgYSBjaGFuZ2VkIFRhZ2dlZCBUZW1wbGF0ZSBDb25maWd1cmF0aW9uIGluIHRoZSBwYWNrYWdlIHNldHRpbmdzXHJcbm1vZHVsZS5leHBvcnRzID1cclxuY2xhc3MgQ3JlYXRlVHRsR3JhbW1hciB7XHJcblxyXG4gIGRpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIGNvbmZpZ0NoYW5nZWRUaW1lcj0gbnVsbDtcclxuICBUVExTQ09QRU5BTUUgPSBgbGFuZ3VhZ2ViYWJlbC50dGxleHRlbnNpb25gXHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVDb25maWcgPSBmYWxzZSkge1xyXG4gICAgaWYgKG9ic2VydmVDb25maWcpICAge1xyXG4gICAgICAvLyBsb29rIGZvciBjaGFuZ2VzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBoYW5kbGVyc1xyXG4gICAgICB0aGlzLmRpc3Bvc2FibGUuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoJ2xhbmd1YWdlLWJhYmVsLnRhZ2dlZFRlbXBsYXRlR3JhbW1hcicsIHRoaXMub2JzZXJ2ZVR0bENvbmZpZy5iaW5kKHRoaXMsIDEwMDAwKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgbmV3IGdyYW1tYXJzIHRvIHJlZ2lzdHJ5XHJcbiAgYWRkR3JhbW1hcnMoZmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGF0b20uZ3JhbW1hcnMubG9hZEdyYW1tYXIoZmlsZW5hbWUsIChlcnIpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gYWRkIEdyYW1tYXIgdG8gcmVnaXN0cnlcXG4ke2ZpbGVuYW1lfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgdGhlIGdyYW1tYXIgZXhpc3RzIHVuZGVyIHRoaXMgU0hBMjU2IGZpbGUgbmFtZVxyXG4gIC8vIElmIG5vdCB0aGVuIHJlbW92ZSBhbGwgdHRsIGdyYW1tYXJzIGFuZCBjcmVhdGUgYSBuZXcgb25lXHJcbiAgLy8gVGhpcyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzICB3aXRoIGEgdHRsIGZpbGVuYW1lXHJcbiAgLy8gaWYgYSBuZXcgZ3JhbW1hciB3YXMgY3JlYXRlZCBvciByZWplY3RzIGlmIGEgcHJvYmxlbS5cclxuICBjcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLmRvZXNHcmFtbWFyRmlsZUV4aXN0KHR0bEZpbGVuYW1lKVxyXG4gICAgICAgIC50aGVuKChpZkZpbGVFeGlzdHMpID0+IHtcclxuICAgICAgICAgIGlmIChpZkZpbGVFeGlzdHMpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR3JhbW1hcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUdGxMYW5ndWFnZUZpbGVzKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVHcmFtbWFyRmlsZSh0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dCkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuYWRkR3JhbW1hcnModHRsRmlsZW5hbWVBYnNvbHV0ZSkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkSW5mbygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGV0YWlsOiBgR3JhbW1hciBjcmVhdGVkIGF0IFxcbiR7dHRsRmlsZW5hbWVBYnNvbHV0ZX1gLGRpc21pc3NhYmxlOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0dGxGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZFdhcm5pbmcoJ2xhbmd1YWdlLWJhYmVsJywge2RldGFpbDogYCR7ZXJyLm1lc3NhZ2V9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgdGhlIHR0bCBncmFtbWFyIGZpbGUgZm9yIHRoaXMgY29uZmlnXHJcbiAgY3JlYXRlR3JhbW1hckZpbGUoZmlsZW5hbWUsdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCB0ZXh0LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgICAgICBlbHNlIHJlc29sdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGNyZWF0ZSBhIEdyYW1tYXIgZmlsZSdzIEpTT04gdGV4dFxyXG4gIGNyZWF0ZUdyYW1tYXJUZXh0KCkge1xyXG4gICAgcmV0dXJuIGB7XHJcbiAgXCJjb21tZW50XCI6IFwiQXV0byBnZW5lcmF0ZWQgVGFnIEV4dGVuc2lvbnMgZm9yIGxhbmd1YWdlLWJhYmVsXCIsXHJcbiAgXCJjb21tZW50XCI6IFwiUGxlYXNlIGRvIG5vdCBlZGl0IHRoaXMgZmlsZSBkaXJlY3RseVwiLFxyXG4gIFwic2NvcGVOYW1lXCI6IFwiJHt0aGlzLlRUTFNDT1BFTkFNRX1cIixcclxuICBcImZpbGVUeXBlc1wiOiBbXSxcclxuICBcInBhdHRlcm5zXCI6IFtcclxuICAgICR7dGhpcy5nZXRUdGxDb25maWcoKS5tYXAoKHR0bFN0cmluZykgPT4gKHRoaXMuY3JlYXRlR3JhbW1hclBhdHRlcm5zKHR0bFN0cmluZykpKX1cclxuICBdXHJcbn1gO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGEgZ3JhbW1hcidzIHBhdHRlcm4gZGVyaXZlZCBmcm9tIGEgdGhlIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdcclxuICAvLyBpbiB0aGUgZm9ybSBtYXRjaFN0cmluZzppbmNsdWRlU2NvcGVcclxuICBjcmVhdGVHcmFtbWFyUGF0dGVybnModHRsU3RyaW5nKSB7XHJcbiAgICBsZXQgbGFzdENvbG9uSW5kZXggPSB0dGxTdHJpbmcubGFzdEluZGV4T2YoJzonKTtcclxuICAgIGxldCBtYXRjaFN0cmluZyA9IHR0bFN0cmluZy5zdWJzdHJpbmcoMCwgbGFzdENvbG9uSW5kZXgpO1xyXG4gICAgbGV0IGluY2x1ZGVTY29wZSA9IHR0bFN0cmluZy5zdWJzdHJpbmcobGFzdENvbG9uSW5kZXgrMSk7XHJcbiAgICBjb25zdCBpc1ZhbGlkSW5jbHVkZVNjb3BlID0gL14oW2EtekEtWl1cXHcqXFwuPykqKFxcdyMoW2EtekEtWl1cXHcqXFwuPykqKT9cXHckLztcclxuXHJcbiAgICBpZiAobWF0Y2hTdHJpbmcubGVuZ3RoIDwgMSB8fCAhaXNWYWxpZEluY2x1ZGVTY29wZS50ZXN0KGluY2x1ZGVTY29wZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiB0aGUgVGFnZ2VkIFRlbXBsYXRlIEdyYW1tYXIgU3RyaW5nICR7dHRsU3RyaW5nfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzUmVnRXhwID0gL15cXFwiLipcXFwiJC87XHJcbiAgICBpZiAoIGlzUmVnRXhwLnRlc3QobWF0Y2hTdHJpbmcpICkge1xyXG4gICAgICAvLyBGb3VuZCBhIHBvc3NpYmxlIHJlZ2V4cCBpbiB0aGUgZm9ybSAvcmVnZXgvIHNvIHN0cmlwIHRoZSAvXHJcbiAgICAgIC8vIFRoaXMgaXMgYSBvbmlndXJ1bWEgcmVnZXggYnV0IHdlIHdpbGwgZG8gYSBzaW1wbGUgSlMgcmVnZXggdGVzdCBmb3JcclxuICAgICAgLy8gdmFsaWRpdHkgYXMgaXQgaXMgbW9zdCBsaWtlbHkgY2xvc2UgZW5vdWdoIVxyXG4gICAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnN1YnN0cmluZygxLCBtYXRjaFN0cmluZy5sZW5ndGggLTEpO1xyXG4gICAgICB0cnkgeyhuZXcgUmVnRXhwKG1hdGNoU3RyaW5nKSkudGVzdChcIlwiKTt9XHJcbiAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBlbnRlcmVkIGFuIGJhZGx5IGZvcm1lZCBSZWdFeHAgaW4gdGhlIFRhZ2dlZCBUZW1wbGF0ZSBHcmFtbWFyIHNldHRpbmdzLlxcbi8ke21hdGNoU3RyaW5nfS9gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGNvbnN0IGVzY2FwZVN0cmluZ1JlZ0V4cCA9IC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZztcclxuICAgICAgLy8gR2V0IGEgdmFsaWQgcmVnZXhwIGVzY2FwZWQgc3RyaW5nLiBlLmcuICcvKiogQGh0bWwgKi8nIC0+ICdcXC9cXCpcXCogQGh0bWwgXFwqXFwvJ1xyXG4gICAgICBtYXRjaFN0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoZXNjYXBlU3RyaW5nUmVnRXhwLCAnXFxcXFxcXFwkJicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBge1xyXG4gICAgICBcImJlZ2luXCI6IFwiXFxcXFxcXFxzKisoJHttYXRjaFN0cmluZ30pXFxcXFxcXFxzKihcXGApXCIsXHJcbiAgICAgIFwiYmVnaW5DYXB0dXJlc1wiOiB7XHJcbiAgICAgICAgXCIxXCI6IHsgXCJuYW1lXCI6IFwiZW50aXR5Lm5hbWUudGFnLmpzXCIgfSxcclxuICAgICAgICBcIjRcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmJlZ2luLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcImVuZFwiOiBcIlxcXFxcXFxccyooPzwhXFxcXFxcXFxcXFxcXFxcXCkoXFxgKVwiLFxyXG4gICAgICBcImVuZENhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnF1YXNpLmVuZC5qc1wiIH1cclxuICAgICAgfSxcclxuICAgICAgXCJwYXR0ZXJuc1wiOiBbXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCJzb3VyY2UuanMuanN4I2xpdGVyYWwtcXVhc2ktZW1iZWRkZWRcIiB9LFxyXG4gICAgICAgIHsgXCJpbmNsdWRlXCI6IFwiJHtpbmNsdWRlU2NvcGV9XCIgfVxyXG4gICAgICBdXHJcbiAgICB9YDtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrcyBhIHR0bCBncmFtbWFyIGZpbGVuYW1lIGV4aXN0c1xyXG4gIC8vIHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0dGxGaWxlTmFtZSBleGlzdHNcclxuICBkb2VzR3JhbW1hckZpbGVFeGlzdCh0dGxGaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgIGZzLmFjY2Vzcyh0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpLCBmcy5GX09LLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgZXJyID8gcmVzb2x2ZShmYWxzZSk6IHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgZnVsbCBwYXRoIHRvIHRoZSBsYW5ndWFnZS1iYWJlbCBncmFtbWFyIGZpbGUgZGlyXHJcbiAgZ2V0R3JhbW1hclBhdGgoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5ub3JtYWxpemUoXHJcbiAgICAgIHBhdGgucmVzb2x2ZShhdG9tLnBhY2thZ2VzLmxvYWRlZFBhY2thZ2VzWydsYW5ndWFnZS1iYWJlbCddLnBhdGgsICcuL2dyYW1tYXJzJylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgYWxsIGxhbmd1YWdlLWJhYmVsIGdyYW1tYXIgZmlsZXNcclxuICBnZXRHcmFtbWFyRmlsZXMoKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLnJlYWRkaXIodGhpcy5nZXRHcmFtbWFyUGF0aCgpLChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZWplY3QobmV3IEVycm9yKGVycikpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyByZWFkIGNvbmZpZ3VyYXRpb25zIGZvciB0YWdnZWQgdGVtcGxhdGVzXHJcbiAgZ2V0VHRsQ29uZmlnKCkge1xyXG4gICAgcmV0dXJuIGF0b20uY29uZmlnLmdldCgnbGFuZ3VhZ2UtYmFiZWwnKS50YWdnZWRUZW1wbGF0ZUdyYW1tYXI7XHJcbiAgfVxyXG5cclxuICAvLyBnZXQgYW4gYXJyYXkgb2YgZ3JhbW1hciB0YWdnZWQgdGVtcGxhdGUgZXh0ZW5zaW9uIGZpbGVuYW1lc1xyXG4gIGdldFR0bEdyYW1tYXJGaWxlcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJGaWxlcygpLnRoZW4oZGlyRmlsZXMgPT4gZGlyRmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGVuYW1lKSB7XHJcbiAgICAgIHJldHVybiAvXnR0bC0vLnRlc3QoZmlsZW5hbWUpO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2VuZXJhdGUgYSBTSEEyNTYgZm9yIHNvbWUgdGV4dFxyXG4gIGdlbmVyYXRlVHRsU0hBMjU2KHN0cmluZ1RvSGFzaCkge1xyXG4gICAgbGV0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XHJcbiAgICBoYXNoLnVwZGF0ZShzdHJpbmdUb0hhc2gpO1xyXG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdoZXgnKTtcclxuICB9XHJcblxyXG4gIC8vIHRhZ2dlZCB0ZW1wbGF0ZSBmaWxlbmFtZVxyXG4gIG1ha2VUdGxHcmFtbWFyRmlsZW5hbWUoaGFzaFN0cmluZykge1xyXG4gICAgcmV0dXJuIGB0dGwtJHtoYXNoU3RyaW5nfS5qc29uYDtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhIGZ1bGx5IHF1YWxpZmllZCBmaWxlbmFtZVxyXG4gIG1ha2VUdGxHcmFtbWFyRmlsZW5hbWVBYnNvdWx1dGUodHRsRmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5nZXRHcmFtbWFyUGF0aCgpLCB0dGxGaWxlbmFtZSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gb2JzZXJ2ZSBjaGFuZ2VzIGluIHRoZSB0YWdnZWRUZW1wbGF0ZUdyYW1tYXIgY29uZmlnIHdoaWNoIHRha2UgcGxhY2VcclxuICAvLyBiZWNhdXNlIG9ic2VydmVkIGNvbmZpZyBjaGFuZ2VzIGFyZSBmaXJlZCBhcyBhIHVzZXIgdHlwZXMgdGhlbSBpbnNpZGVcclxuICAvLyBzZXR0aW5ncyB3ZSBuZWVkIHRvIGRlbGF5IHByb2Nlc3NpbmcgdGhlIGFycmF5IHN0cmluZ3MsIHVudGlsIGxhc3QgY2hhclxyXG4gIC8vIGVudGVyZWQgd2FzIHNldFRpbWVvdXQgc2Vjb25kcyBhZ28uIHBhcnNlIHRhZ2dlZCB0ZW1wbGF0ZSBjb25maWd1cmF0aW9uXHJcbiAgLy8gYW5kIHRoZW4gY3JlYXRlIGdyYW1tYXIgYW5kIGdlbmVyYXRlIGEgU0hBMjU2IGhhc2ggZnJvbSB0aGUgZ3JhbW1hclxyXG4gIG9ic2VydmVUdGxDb25maWcodGltZW91dCkge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnQ2hhbmdlZFRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5jb25maWdDaGFuZ2VkVGltZXIpO1xyXG4gICAgdGhpcy5jb25maWdDaGFuZ2VkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBncmFtbWFyVGV4dCA9IHRoaXMuY3JlYXRlR3JhbW1hclRleHQoKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5nZW5lcmF0ZVR0bFNIQTI1NihncmFtbWFyVGV4dCk7XHJcbiAgICAgICAgY29uc3QgdHRsRmlsZW5hbWUgPSB0aGlzLm1ha2VUdGxHcmFtbWFyRmlsZW5hbWUoaGFzaCk7XHJcbiAgICAgICAgY29uc3QgdHRsRmlsZW5hbWVBYnNvbHV0ZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaChlcnIpIHtcclxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkV2FybmluZygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGV0YWlsOiBgJHtlcnIubWVzc2FnZX1gLGRpc21pc3NhYmxlOiB0cnVlfSk7XHJcbiAgICAgIH1cclxuICAgIH0sIHRpbWVvdXQpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGdyYW1tYXJzIGJlZm9yZSB1cG9kYXRpbmdcclxuICByZW1vdmVHcmFtbWFycygpIHtcclxuICAgIGF0b20uZ3JhbW1hcnMucmVtb3ZlR3JhbW1hckZvclNjb3BlTmFtZSh0aGlzLlRUTFNDT1BFTkFNRSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYWxsIGxhbmd1YWdlIGZpbGVzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBHcmFtbWFyRmlsZXMgYXJyYXlcclxuICByZW1vdmVUdGxMYW5ndWFnZUZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHRsR3JhbW1hckZpbGVzKCkudGhlbigodHRsR3JhbW1hckZpbGVzKSA9PiB7XHJcbiAgICAgIGZvciAobGV0IHR0bEdyYW1tYXJGaWxlbmFtZSBvZiB0dGxHcmFtbWFyRmlsZXMpIHtcclxuICAgICAgICBsZXQgdHRsR3JhbW1hckZpbGVBYnNvdWx0ZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxHcmFtbWFyRmlsZW5hbWUpO1xyXG4gICAgICAgIGZzLnVubGluayh0dGxHcmFtbWFyRmlsZUFic291bHRlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxufTtcclxuIl19