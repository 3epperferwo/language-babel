'use strict';

/*global atom*/
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTL_GRAMMAR_NAME = 'language-babel-extension';
    this.TTL_SCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this, 10000)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, err => {
        if (err) {
          reject(new Error(`Unable to add Grammar to registry\n${ filename }`));
        } else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a ttl filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename;
    let ttlFilenameAbsolute = _ref.ttlFilenameAbsolute;
    let grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {
      this.doesGrammarFileExist(ttlFilename).then(ifFileExists => {
        if (ifFileExists) {
          resolve();
        } else {
          this.removeGrammars();
          this.removeTtlLanguageFiles().then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => {
            atom.notifications.addInfo('language-babel', { detail: `Grammar created at \n${ ttlFilenameAbsolute }`, dismissable: true });
            resolve(ttlFilename);
          }).catch(err => {
            atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
            reject(err);
          });
        }
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject(new Error(err));else resolve();
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "name": "${ this.TTL_GRAMMAR_NAME }",
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${ this.TTL_SCOPENAME }",
  "fileTypes": [],
  "patterns": [
    ${ this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString)) }
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/.test(includeScope);
    const isQuotedMatchString = /^\".*\"$/.test(matchString);

    if (matchString.length < 1 || !isValidIncludeScope) {
      throw new Error(`Error in the Tagged Template Grammar String ${ ttlString }`);
    }

    if (isQuotedMatchString) {
      // Found a possible regexp in the form "regex" so strip the "
      matchString = matchString.substring(1, matchString.length - 1);
      try {
        // We need to call oniguruma's constructor via this convoluted method as I can't include
        // the github/atom/node-oniguruma package as npm on Windows get node-gyp errors unless a
        // user has installed a compiler. Find Atom's Oniguruma and call the constructor.
        if (typeof atom.grammars.grammars === "object") {
          atom.grammars.grammars.every(obj => {
            if (obj.packageName === "language-babel") {
              let ref, ref1, ref2;
              if ((ref = obj.firstLineRegex) != null) {
                if ((ref1 = ref.scanner) != null) {
                  if ((ref2 = ref1.__proto__) != null) {
                    if (typeof ref2.constructor === "function") {
                      // Change JSON/JS type string to a valid regex
                      let onigString = matchString.replace(/\\\\/g, "\\"); // double slashes to single
                      onigString = onigString.replace(/\\"/g, "\""); // escaped quote to quote
                      // now call new obj.firstLineRegex.scanner.__proto__.constructor([onigString]);
                      // to validate the regex
                      new ref2.constructor([onigString]);
                    }
                  }
                }
              }
              return false;
            } else return true;
          });
        }
      } catch (err) {
        throw new Error(`You entered an badly formed RegExp in the Tagged Template Grammar settings.\n${ matchString }\n${ err }`);
      }
    } else if (/"/g.test(matchString)) {
      throw new Error(`Bad literal string in the Tagged Template Grammar settings.\n${ matchString }`);
    } else {
      // User entered a literal string which may contain chars that a special inside a regex.
      // Escape any special chars e.g. '/** @html */' -> '\/\*\* @html \*\/'
      // The string stored by Atom in the config has the \\ already escaped.
      const escapeStringRegExp = /[|{}()[\]^$+*?.]/g;
      const preEscapedSlash = /\\/g;
      matchString = matchString.replace(preEscapedSlash, '\\\\\\\\');
      matchString = matchString.replace(escapeStringRegExp, '\\\\$&');
    }

    return `{
      "contentName": "${ includeScope.match(/^[^#]*/)[0] }",
      "begin": "\\\\s*+(${ matchString })\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.js" },
        "2": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "source.js.jsx#literal-quasi-embedded" },
        { "include": "${ includeScope }" }
      ]
    }`;
  }

  // checks a ttl grammar filename exists
  // returns a Promise that resolves to true if ttlFileName exists
  doesGrammarFileExist(ttlFilename) {
    return new Promise(resolve => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, err => {
        err ? resolve(false) : resolve(true);
      });
    });
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject(new Error(err));else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return (/^ttl-/.test(filename)
      );
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    let hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${ hashString }.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(timeout) {
    if (this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText });
      } catch (err) {
        atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
      }
    }, timeout);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTL_SCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZS10dGwtZ3JhbW1hci5qcyJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJDcmVhdGVUdGxHcmFtbWFyIiwiY29uc3RydWN0b3IiLCJvYnNlcnZlQ29uZmlnIiwiZGlzcG9zYWJsZSIsImNvbmZpZ0NoYW5nZWRUaW1lciIsIlRUTF9HUkFNTUFSX05BTUUiLCJUVExfU0NPUEVOQU1FIiwiYWRkIiwiYXRvbSIsImNvbmZpZyIsIm9ic2VydmUiLCJvYnNlcnZlVHRsQ29uZmlnIiwiYmluZCIsImRlc3Ryb3kiLCJkaXNwb3NlIiwiYWRkR3JhbW1hcnMiLCJmaWxlbmFtZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZ3JhbW1hcnMiLCJsb2FkR3JhbW1hciIsImVyciIsIkVycm9yIiwiY3JlYXRlR3JhbW1hciIsInR0bEZpbGVuYW1lIiwidHRsRmlsZW5hbWVBYnNvbHV0ZSIsImdyYW1tYXJUZXh0IiwiZG9lc0dyYW1tYXJGaWxlRXhpc3QiLCJ0aGVuIiwiaWZGaWxlRXhpc3RzIiwicmVtb3ZlR3JhbW1hcnMiLCJyZW1vdmVUdGxMYW5ndWFnZUZpbGVzIiwiY3JlYXRlR3JhbW1hckZpbGUiLCJub3RpZmljYXRpb25zIiwiYWRkSW5mbyIsImRldGFpbCIsImRpc21pc3NhYmxlIiwiY2F0Y2giLCJhZGRXYXJuaW5nIiwibWVzc2FnZSIsInRleHQiLCJ3cml0ZUZpbGUiLCJjcmVhdGVHcmFtbWFyVGV4dCIsImdldFR0bENvbmZpZyIsIm1hcCIsInR0bFN0cmluZyIsImNyZWF0ZUdyYW1tYXJQYXR0ZXJucyIsImxhc3RDb2xvbkluZGV4IiwibGFzdEluZGV4T2YiLCJtYXRjaFN0cmluZyIsInN1YnN0cmluZyIsImluY2x1ZGVTY29wZSIsImlzVmFsaWRJbmNsdWRlU2NvcGUiLCJ0ZXN0IiwiaXNRdW90ZWRNYXRjaFN0cmluZyIsImxlbmd0aCIsImV2ZXJ5Iiwib2JqIiwicGFja2FnZU5hbWUiLCJyZWYiLCJyZWYxIiwicmVmMiIsImZpcnN0TGluZVJlZ2V4Iiwic2Nhbm5lciIsIl9fcHJvdG9fXyIsIm9uaWdTdHJpbmciLCJyZXBsYWNlIiwiZXNjYXBlU3RyaW5nUmVnRXhwIiwicHJlRXNjYXBlZFNsYXNoIiwibWF0Y2giLCJhY2Nlc3MiLCJtYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlIiwiRl9PSyIsImdldEdyYW1tYXJQYXRoIiwibm9ybWFsaXplIiwicGFja2FnZXMiLCJsb2FkZWRQYWNrYWdlcyIsImdldEdyYW1tYXJGaWxlcyIsInJlYWRkaXIiLCJkYXRhIiwiZ2V0IiwidGFnZ2VkVGVtcGxhdGVHcmFtbWFyIiwiZ2V0VHRsR3JhbW1hckZpbGVzIiwiZGlyRmlsZXMiLCJmaWx0ZXIiLCJnZW5lcmF0ZVR0bFNIQTI1NiIsInN0cmluZ1RvSGFzaCIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwibWFrZVR0bEdyYW1tYXJGaWxlbmFtZSIsImhhc2hTdHJpbmciLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInJlbW92ZUdyYW1tYXJGb3JTY29wZU5hbWUiLCJ0dGxHcmFtbWFyRmlsZXMiLCJ0dGxHcmFtbWFyRmlsZW5hbWUiLCJ0dGxHcmFtbWFyRmlsZUFic291bHRlIiwidW5saW5rIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsTUFBTUEsU0FBU0MsUUFBUSxRQUFSLENBQWY7QUFDQSxNQUFNQyxLQUFLRCxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1FLE9BQU9GLFFBQVEsTUFBUixDQUFiO0FBQ0EsTUFBTUcsc0JBQXNCSCxRQUFRLE1BQVIsRUFBZ0JHLG1CQUE1Qzs7QUFFQTtBQUNBO0FBQ0FDLE9BQU9DLE9BQVAsR0FDQSxNQUFNQyxnQkFBTixDQUF1Qjs7QUFPckJDLGdCQUFtQztBQUFBLFFBQXZCQyxhQUF1Qix5REFBUCxLQUFPO0FBQUEsU0FMbkNDLFVBS21DLEdBTHRCLElB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Q0YsS0FYeUIsRUFXdkJ5RCxPQVh1QixDQUExQjtBQVlEOztBQUVEO0FBQ0EvRCxtQkFBaUI7QUFDZnZCLFNBQUtZLFFBQUwsQ0FBYzZFLHlCQUFkLENBQXdDLEtBQUszRixhQUE3QztBQUNEOztBQUVEO0FBQ0EwQiwyQkFBeUI7QUFDdkIsV0FBTyxLQUFLbUQsa0JBQUwsR0FBMEJ0RCxJQUExQixDQUFnQ3FFLGVBQUQsSUFBcUI7QUFDekQsV0FBSyxJQUFJQyxrQkFBVCxJQUErQkQsZUFBL0IsRUFBZ0Q7QUFDOUMsWUFBSUUseUJBQXlCLEtBQUs1QiwrQkFBTCxDQUFxQzJCLGtCQUFyQyxDQUE3QjtBQUNBeEcsV0FBRzBHLE1BQUgsQ0FBVUQsc0JBQVY7QUFDRDtBQUNGLEtBTE0sQ0FBUDtBQU9EO0FBalFvQixDQUR2QiIsImZpbGUiOiJjcmVhdGUtdHRsLWdyYW1tYXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBhdG9tKi9cclxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3QgQ29tcG9zaXRlRGlzcG9zYWJsZSA9IHJlcXVpcmUoJ2F0b20nKS5Db21wb3NpdGVEaXNwb3NhYmxlO1xyXG5cclxuLy8gVGhpcyBDbGFzcyBpcyByZXBzb25zaWJsZSBmb3IgY3JlYXRpbmcgYSBuZXcgVGFnZ2VkIFRlbXBsYXRlIGdyYW1tYXJcclxuLy8gb24gZGV0ZWN0aW9uIG9mIGEgY2hhbmdlZCBUYWdnZWQgVGVtcGxhdGUgQ29uZmlndXJhdGlvbiBpbiB0aGUgcGFja2FnZSBzZXR0aW5nc1xyXG5tb2R1bGUuZXhwb3J0cyA9XHJcbmNsYXNzIENyZWF0ZVR0bEdyYW1tYXIge1xyXG5cclxuICBkaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICBjb25maWdDaGFuZ2VkVGltZXI9IG51bGw7XHJcbiAgVFRMX0dSQU1NQVJfTkFNRSA9ICdsYW5ndWFnZS1iYWJlbC1leHRlbnNpb24nO1xyXG4gIFRUTF9TQ09QRU5BTUUgPSBgbGFuZ3VhZ2ViYWJlbC50dGxleHRlbnNpb25gO1xyXG5cclxuICBjb25zdHJ1Y3RvcihvYnNlcnZlQ29uZmlnID0gZmFsc2UpIHtcclxuICAgIGlmIChvYnNlcnZlQ29uZmlnKSAgIHtcclxuICAgICAgLy8gbG9vayBmb3IgY2hhbmdlcyBpbiB0YWdnZWQgdGVtcGxhdGUgaGFuZGxlcnNcclxuICAgICAgdGhpcy5kaXNwb3NhYmxlLmFkZChhdG9tLmNvbmZpZy5vYnNlcnZlKCdsYW5ndWFnZS1iYWJlbC50YWdnZWRUZW1wbGF0ZUdyYW1tYXInLCB0aGlzLm9ic2VydmVUdGxDb25maWcuYmluZCh0aGlzLCAxMDAwMCkpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gYWRkIG5ldyBncmFtbWFycyB0byByZWdpc3RyeVxyXG4gIGFkZEdyYW1tYXJzKGZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBhdG9tLmdyYW1tYXJzLmxvYWRHcmFtbWFyKGZpbGVuYW1lLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5hYmxlIHRvIGFkZCBHcmFtbWFyIHRvIHJlZ2lzdHJ5XFxuJHtmaWxlbmFtZX1gKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgcmVzb2x2ZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHRoZSBncmFtbWFyIGV4aXN0cyB1bmRlciB0aGlzIFNIQTI1NiBmaWxlIG5hbWVcclxuICAvLyBJZiBub3QgdGhlbiByZW1vdmUgYWxsIHR0bCBncmFtbWFycyBhbmQgY3JlYXRlIGEgbmV3IG9uZVxyXG4gIC8vIFRoaXMgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyAgd2l0aCBhIHR0bCBmaWxlbmFtZVxyXG4gIC8vIGlmIGEgbmV3IGdyYW1tYXIgd2FzIGNyZWF0ZWQgb3IgcmVqZWN0cyBpZiBhIHByb2JsZW0uXHJcbiAgY3JlYXRlR3JhbW1hcih7dHRsRmlsZW5hbWUsIHR0bEZpbGVuYW1lQWJzb2x1dGUsIGdyYW1tYXJUZXh0fSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5kb2VzR3JhbW1hckZpbGVFeGlzdCh0dGxGaWxlbmFtZSlcclxuICAgICAgICAudGhlbigoaWZGaWxlRXhpc3RzKSA9PiB7XHJcbiAgICAgICAgICBpZiAoaWZGaWxlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUdyYW1tYXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVHRsTGFuZ3VhZ2VGaWxlcygpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuY3JlYXRlR3JhbW1hckZpbGUodHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHQpKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmFkZEdyYW1tYXJzKHR0bEZpbGVuYW1lQWJzb2x1dGUpKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZEluZm8oJ2xhbmd1YWdlLWJhYmVsJywge2RldGFpbDogYEdyYW1tYXIgY3JlYXRlZCBhdCBcXG4ke3R0bEZpbGVuYW1lQWJzb2x1dGV9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIHJlc29sdmUodHRsRmlsZW5hbWUpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKCdsYW5ndWFnZS1iYWJlbCcsIHtkZXRhaWw6IGAke2Vyci5tZXNzYWdlfWAsZGlzbWlzc2FibGU6IHRydWV9KTtcclxuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHdyaXRlIHRoZSB0dGwgZ3JhbW1hciBmaWxlIGZvciB0aGlzIGNvbmZpZ1xyXG4gIGNyZWF0ZUdyYW1tYXJGaWxlKGZpbGVuYW1lLHRleHQpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZzLndyaXRlRmlsZShmaWxlbmFtZSwgdGV4dCwgKGVycikgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XHJcbiAgICAgICAgZWxzZSByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBjcmVhdGUgYSBHcmFtbWFyIGZpbGUncyBKU09OIHRleHRcclxuICBjcmVhdGVHcmFtbWFyVGV4dCgpIHtcclxuICAgIHJldHVybiBge1xyXG4gIFwibmFtZVwiOiBcIiR7dGhpcy5UVExfR1JBTU1BUl9OQU1FfVwiLFxyXG4gIFwiY29tbWVudFwiOiBcIkF1dG8gZ2VuZXJhdGVkIFRhZyBFeHRlbnNpb25zIGZvciBsYW5ndWFnZS1iYWJlbFwiLFxyXG4gIFwiY29tbWVudFwiOiBcIlBsZWFzZSBkbyBub3QgZWRpdCB0aGlzIGZpbGUgZGlyZWN0bHlcIixcclxuICBcInNjb3BlTmFtZVwiOiBcIiR7dGhpcy5UVExfU0NPUEVOQU1FfVwiLFxyXG4gIFwiZmlsZVR5cGVzXCI6IFtdLFxyXG4gIFwicGF0dGVybnNcIjogW1xyXG4gICAgJHt0aGlzLmdldFR0bENvbmZpZygpLm1hcCgodHRsU3RyaW5nKSA9PiAodGhpcy5jcmVhdGVHcmFtbWFyUGF0dGVybnModHRsU3RyaW5nKSkpfVxyXG4gIF1cclxufWA7XHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgYSBncmFtbWFyJ3MgcGF0dGVybiBkZXJpdmVkIGZyb20gYSB0aGUgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZ1xyXG4gIC8vIGluIHRoZSBmb3JtIG1hdGNoU3RyaW5nOmluY2x1ZGVTY29wZVxyXG4gIGNyZWF0ZUdyYW1tYXJQYXR0ZXJucyh0dGxTdHJpbmcpIHtcclxuICAgIGxldCBsYXN0Q29sb25JbmRleCA9IHR0bFN0cmluZy5sYXN0SW5kZXhPZignOicpO1xyXG4gICAgbGV0IG1hdGNoU3RyaW5nID0gdHRsU3RyaW5nLnN1YnN0cmluZygwLCBsYXN0Q29sb25JbmRleCk7XHJcbiAgICBsZXQgaW5jbHVkZVNjb3BlID0gdHRsU3RyaW5nLnN1YnN0cmluZyhsYXN0Q29sb25JbmRleCsxKTtcclxuICAgIGNvbnN0IGlzVmFsaWRJbmNsdWRlU2NvcGUgPSAvXihbYS16QS1aXVxcdypcXC4/KSooXFx3IyhbYS16QS1aXVxcdypcXC4/KSopP1xcdyQvLnRlc3QoaW5jbHVkZVNjb3BlKTtcclxuICAgIGNvbnN0IGlzUXVvdGVkTWF0Y2hTdHJpbmcgPSAvXlxcXCIuKlxcXCIkLy50ZXN0KG1hdGNoU3RyaW5nKTtcclxuXHJcbiAgICBpZiAobWF0Y2hTdHJpbmcubGVuZ3RoIDwgMSB8fCAhaXNWYWxpZEluY2x1ZGVTY29wZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIHRoZSBUYWdnZWQgVGVtcGxhdGUgR3JhbW1hciBTdHJpbmcgJHt0dGxTdHJpbmd9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCBpc1F1b3RlZE1hdGNoU3RyaW5nICkge1xyXG4gICAgICAvLyBGb3VuZCBhIHBvc3NpYmxlIHJlZ2V4cCBpbiB0aGUgZm9ybSBcInJlZ2V4XCIgc28gc3RyaXAgdGhlIFwiXHJcbiAgICAgIG1hdGNoU3RyaW5nID0gbWF0Y2hTdHJpbmcuc3Vic3RyaW5nKDEsIG1hdGNoU3RyaW5nLmxlbmd0aCAtMSk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxsIG9uaWd1cnVtYSdzIGNvbnN0cnVjdG9yIHZpYSB0aGlzIGNvbnZvbHV0ZWQgbWV0aG9kIGFzIEkgY2FuJ3QgaW5jbHVkZVxyXG4gICAgICAgIC8vIHRoZSBnaXRodWIvYXRvbS9ub2RlLW9uaWd1cnVtYSBwYWNrYWdlIGFzIG5wbSBvbiBXaW5kb3dzIGdldCBub2RlLWd5cCBlcnJvcnMgdW5sZXNzIGFcclxuICAgICAgICAvLyB1c2VyIGhhcyBpbnN0YWxsZWQgYSBjb21waWxlci4gRmluZCBBdG9tJ3MgT25pZ3VydW1hIGFuZCBjYWxsIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgICAgICBpZiAodHlwZW9mIGF0b20uZ3JhbW1hcnMuZ3JhbW1hcnMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgIGF0b20uZ3JhbW1hcnMuZ3JhbW1hcnMuZXZlcnkoKG9iaikgPT4ge1xyXG4gICAgICAgICAgICBpZiAob2JqLnBhY2thZ2VOYW1lID09PSBcImxhbmd1YWdlLWJhYmVsXCIpIHtcclxuICAgICAgICAgICAgICBsZXQgcmVmLCByZWYxLCByZWYyO1xyXG4gICAgICAgICAgICAgIGlmICgocmVmID0gb2JqLmZpcnN0TGluZVJlZ2V4KSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHJlZjEgPSByZWYuc2Nhbm5lcikgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoKHJlZjIgPSByZWYxLl9fcHJvdG9fXykgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmMi5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgSlNPTi9KUyB0eXBlIHN0cmluZyB0byBhIHZhbGlkIHJlZ2V4XHJcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgb25pZ1N0cmluZyA9IG1hdGNoU3RyaW5nLnJlcGxhY2UoL1xcXFxcXFxcL2csXCJcXFxcXCIpOyAvLyBkb3VibGUgc2xhc2hlcyB0byBzaW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgIG9uaWdTdHJpbmcgPSBvbmlnU3RyaW5nLnJlcGxhY2UoL1xcXFxcIi9nLFwiXFxcIlwiKTsgLy8gZXNjYXBlZCBxdW90ZSB0byBxdW90ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gbm93IGNhbGwgbmV3IG9iai5maXJzdExpbmVSZWdleC5zY2FubmVyLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvcihbb25pZ1N0cmluZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdmFsaWRhdGUgdGhlIHJlZ2V4XHJcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgcmVmMi5jb25zdHJ1Y3Rvcihbb25pZ1N0cmluZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZW50ZXJlZCBhbiBiYWRseSBmb3JtZWQgUmVnRXhwIGluIHRoZSBUYWdnZWQgVGVtcGxhdGUgR3JhbW1hciBzZXR0aW5ncy5cXG4ke21hdGNoU3RyaW5nfVxcbiR7ZXJyfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggL1wiL2cudGVzdChtYXRjaFN0cmluZykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgbGl0ZXJhbCBzdHJpbmcgaW4gdGhlIFRhZ2dlZCBUZW1wbGF0ZSBHcmFtbWFyIHNldHRpbmdzLlxcbiR7bWF0Y2hTdHJpbmd9YCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gVXNlciBlbnRlcmVkIGEgbGl0ZXJhbCBzdHJpbmcgd2hpY2ggbWF5IGNvbnRhaW4gY2hhcnMgdGhhdCBhIHNwZWNpYWwgaW5zaWRlIGEgcmVnZXguXHJcbiAgICAgIC8vIEVzY2FwZSBhbnkgc3BlY2lhbCBjaGFycyBlLmcuICcvKiogQGh0bWwgKi8nIC0+ICdcXC9cXCpcXCogQGh0bWwgXFwqXFwvJ1xyXG4gICAgICAvLyBUaGUgc3RyaW5nIHN0b3JlZCBieSBBdG9tIGluIHRoZSBjb25maWcgaGFzIHRoZSBcXFxcIGFscmVhZHkgZXNjYXBlZC5cclxuICAgICAgY29uc3QgZXNjYXBlU3RyaW5nUmVnRXhwID0gL1t8e30oKVtcXF1eJCsqPy5dL2c7XHJcbiAgICAgIGNvbnN0IHByZUVzY2FwZWRTbGFzaCA9IC9cXFxcL2c7XHJcbiAgICAgIG1hdGNoU3RyaW5nID0gbWF0Y2hTdHJpbmcucmVwbGFjZShwcmVFc2NhcGVkU2xhc2gsICdcXFxcXFxcXFxcXFxcXFxcJyk7XHJcbiAgICAgIG1hdGNoU3RyaW5nID0gbWF0Y2hTdHJpbmcucmVwbGFjZShlc2NhcGVTdHJpbmdSZWdFeHAsICdcXFxcXFxcXCQmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGB7XHJcbiAgICAgIFwiY29udGVudE5hbWVcIjogXCIke2luY2x1ZGVTY29wZS5tYXRjaCgvXlteI10qLylbMF19XCIsXHJcbiAgICAgIFwiYmVnaW5cIjogXCJcXFxcXFxcXHMqKygke21hdGNoU3RyaW5nfSlcXFxcXFxcXHMqKFxcYClcIixcclxuICAgICAgXCJiZWdpbkNhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS50YWcuanNcIiB9LFxyXG4gICAgICAgIFwiMlwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24ucXVhc2kuYmVnaW4uanNcIiB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZW5kXCI6IFwiXFxcXFxcXFxzKig/PCFcXFxcXFxcXFxcXFxcXFxcKShcXGApXCIsXHJcbiAgICAgIFwiZW5kQ2FwdHVyZXNcIjoge1xyXG4gICAgICAgIFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24ucXVhc2kuZW5kLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInBhdHRlcm5zXCI6IFtcclxuICAgICAgICB7IFwiaW5jbHVkZVwiOiBcInNvdXJjZS5qcy5qc3gjbGl0ZXJhbC1xdWFzaS1lbWJlZGRlZFwiIH0sXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCIke2luY2x1ZGVTY29wZX1cIiB9XHJcbiAgICAgIF1cclxuICAgIH1gO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2tzIGEgdHRsIGdyYW1tYXIgZmlsZW5hbWUgZXhpc3RzXHJcbiAgLy8gcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHR0bEZpbGVOYW1lIGV4aXN0c1xyXG4gIGRvZXNHcmFtbWFyRmlsZUV4aXN0KHR0bEZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgZnMuYWNjZXNzKHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSksIGZzLkZfT0ssIChlcnIpID0+IHtcclxuICAgICAgICBlcnIgPyByZXNvbHZlKGZhbHNlKTogcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGdldCBmdWxsIHBhdGggdG8gdGhlIGxhbmd1YWdlLWJhYmVsIGdyYW1tYXIgZmlsZSBkaXJcclxuICBnZXRHcmFtbWFyUGF0aCgpIHtcclxuICAgIHJldHVybiBwYXRoLm5vcm1hbGl6ZShcclxuICAgICAgcGF0aC5yZXNvbHZlKGF0b20ucGFja2FnZXMubG9hZGVkUGFja2FnZXNbJ2xhbmd1YWdlLWJhYmVsJ10ucGF0aCwgJy4vZ3JhbW1hcnMnKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhbiBhcnJheSBvZiBhbGwgbGFuZ3VhZ2UtYmFiZWwgZ3JhbW1hciBmaWxlc1xyXG4gIGdldEdyYW1tYXJGaWxlcygpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpID0+IHtcclxuICAgICAgZnMucmVhZGRpcih0aGlzLmdldEdyYW1tYXJQYXRoKCksKGVyciwgZGF0YSkgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHJlYWQgY29uZmlndXJhdGlvbnMgZm9yIHRhZ2dlZCB0ZW1wbGF0ZXNcclxuICBnZXRUdGxDb25maWcoKSB7XHJcbiAgICByZXR1cm4gYXRvbS5jb25maWcuZ2V0KCdsYW5ndWFnZS1iYWJlbCcpLnRhZ2dlZFRlbXBsYXRlR3JhbW1hcjtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhbiBhcnJheSBvZiBncmFtbWFyIHRhZ2dlZCB0ZW1wbGF0ZSBleHRlbnNpb24gZmlsZW5hbWVzXHJcbiAgZ2V0VHRsR3JhbW1hckZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0R3JhbW1hckZpbGVzKCkudGhlbihkaXJGaWxlcyA9PiBkaXJGaWxlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZW5hbWUpIHtcclxuICAgICAgcmV0dXJuIC9edHRsLS8udGVzdChmaWxlbmFtZSk7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAvLyBnZW5lcmF0ZSBhIFNIQTI1NiBmb3Igc29tZSB0ZXh0XHJcbiAgZ2VuZXJhdGVUdGxTSEEyNTYoc3RyaW5nVG9IYXNoKSB7XHJcbiAgICBsZXQgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcclxuICAgIGhhc2gudXBkYXRlKHN0cmluZ1RvSGFzaCk7XHJcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gdGFnZ2VkIHRlbXBsYXRlIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYHR0bC0ke2hhc2hTdHJpbmd9Lmpzb25gO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGEgZnVsbHkgcXVhbGlmaWVkIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLmdldEdyYW1tYXJQYXRoKCksIHR0bEZpbGVuYW1lKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBvYnNlcnZlIGNoYW5nZXMgaW4gdGhlIHRhZ2dlZFRlbXBsYXRlR3JhbW1hciBjb25maWcgd2hpY2ggdGFrZSBwbGFjZVxyXG4gIC8vIGJlY2F1c2Ugb2JzZXJ2ZWQgY29uZmlnIGNoYW5nZXMgYXJlIGZpcmVkIGFzIGEgdXNlciB0eXBlcyB0aGVtIGluc2lkZVxyXG4gIC8vIHNldHRpbmdzIHdlIG5lZWQgdG8gZGVsYXkgcHJvY2Vzc2luZyB0aGUgYXJyYXkgc3RyaW5ncywgdW50aWwgbGFzdCBjaGFyXHJcbiAgLy8gZW50ZXJlZCB3YXMgc2V0VGltZW91dCBzZWNvbmRzIGFnby4gcGFyc2UgdGFnZ2VkIHRlbXBsYXRlIGNvbmZpZ3VyYXRpb25cclxuICAvLyBhbmQgdGhlbiBjcmVhdGUgZ3JhbW1hciBhbmQgZ2VuZXJhdGUgYSBTSEEyNTYgaGFzaCBmcm9tIHRoZSBncmFtbWFyXHJcbiAgb2JzZXJ2ZVR0bENvbmZpZyh0aW1lb3V0KSB7XHJcbiAgICBpZiAodGhpcy5jb25maWdDaGFuZ2VkVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lcik7XHJcbiAgICB0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGdyYW1tYXJUZXh0ID0gdGhpcy5jcmVhdGVHcmFtbWFyVGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmdlbmVyYXRlVHRsU0hBMjU2KGdyYW1tYXJUZXh0KTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoKTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZUFic29sdXRlID0gdGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEZpbGVuYW1lKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUdyYW1tYXIoe3R0bEZpbGVuYW1lLCB0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNhdGNoKGVycikge1xyXG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKCdsYW5ndWFnZS1iYWJlbCcsIHtkZXRhaWw6IGAke2Vyci5tZXNzYWdlfWAsZGlzbWlzc2FibGU6IHRydWV9KTtcclxuICAgICAgfVxyXG4gICAgfSwgdGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZ3JhbW1hcnMgYmVmb3JlIHVwb2RhdGluZ1xyXG4gIHJlbW92ZUdyYW1tYXJzKCkge1xyXG4gICAgYXRvbS5ncmFtbWFycy5yZW1vdmVHcmFtbWFyRm9yU2NvcGVOYW1lKHRoaXMuVFRMX1NDT1BFTkFNRSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYWxsIGxhbmd1YWdlIGZpbGVzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBHcmFtbWFyRmlsZXMgYXJyYXlcclxuICByZW1vdmVUdGxMYW5ndWFnZUZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHRsR3JhbW1hckZpbGVzKCkudGhlbigodHRsR3JhbW1hckZpbGVzKSA9PiB7XHJcbiAgICAgIGZvciAobGV0IHR0bEdyYW1tYXJGaWxlbmFtZSBvZiB0dGxHcmFtbWFyRmlsZXMpIHtcclxuICAgICAgICBsZXQgdHRsR3JhbW1hckZpbGVBYnNvdWx0ZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxHcmFtbWFyRmlsZW5hbWUpO1xyXG4gICAgICAgIGZzLnVubGluayh0dGxHcmFtbWFyRmlsZUFic291bHRlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxufTtcclxuIl19